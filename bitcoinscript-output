// Push initial hash values onto the stack
{u32_push(0x5be0cd19)}
{u32_push(0x1f83d9ab)}
{u32_push(0x9b05688c)}
{u32_push(0x510e527f)}
{u32_push(0xa54ff53a)}
{u32_push(0x3c6ef372)}
{u32_push(0xbb67ae85)}
{u32_push(0x6a09e667)}
// Extend message schedule w[16] to w[63]
// Calculate w[16]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x776f6273)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x776f6273)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x776f6273)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x8073656e, 0x736f7243)}
// Calculate w[17]
{
        u32_push(0x38010000)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x38010000)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x38010000)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x696f7420)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x696f7420)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x696f7420)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x776f6273)}
// Calculate w[18]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x2074656c)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x2074656c)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x2074656c)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x696f7420)}
// Calculate w[19]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x6c6c696b)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6c6c696b)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6c6c696b)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x2074656c)}
// Calculate w[20]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x20676e69)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x20676e69)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x20676e69)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x6c6c696b)}
// Calculate w[21]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x656d6147)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x656d6147)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x656d6147)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x20676e69)}
// Calculate w[22]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x20664f20)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x20664f20)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x20664f20)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x38010000, 0x656d6147)}
// Calculate w[23]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x6f726854)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6f726854)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6f726854)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x20664f20)}
// Calculate w[24]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x8073656e)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x8073656e)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x8073656e)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x6f726854)}
// Calculate w[25]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x8073656e)}
// Calculate w[26]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[27]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[28]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[29]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[30]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x38010000)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x38010000)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x38010000)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[31]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x38010000)}
// Calculate w[32]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[33]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[34]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[35]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[36]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[37]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[38]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[39]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[40]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[41]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[42]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[43]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[44]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[45]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[46]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[47]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[48]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[49]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[50]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[51]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[52]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[53]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[54]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[55]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[56]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[57]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[58]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[59]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[60]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[61]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[62]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Calculate w[63]
{
        u32_push(0x0)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x0)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{
        u32_push(0x0)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x0)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x0)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{u32_add(0x0, 0x0)}
// Initial hash values and W[t] should already be on the stack
// Round 1
{u32_push(0x428a2f98)} // Push constant K[0] value 0x428a2f98
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 2
{u32_push(0x71374491)} // Push constant K[1] value 0x71374491
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 3
{u32_push(0xb5c0fbcf)} // Push constant K[2] value 0xb5c0fbcf
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 4
{u32_push(0xe9b5dba5)} // Push constant K[3] value 0xe9b5dba5
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 5
{u32_push(0x3956c25b)} // Push constant K[4] value 0x3956c25b
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 6
{u32_push(0x59f111f1)} // Push constant K[5] value 0x59f111f1
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 7
{u32_push(0x923f82a4)} // Push constant K[6] value 0x923f82a4
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 8
{u32_push(0xab1c5ed5)} // Push constant K[7] value 0xab1c5ed5
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 9
{u32_push(0xd807aa98)} // Push constant K[8] value 0xd807aa98
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 10
{u32_push(0x12835b01)} // Push constant K[9] value 0x12835b01
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 11
{u32_push(0x243185be)} // Push constant K[10] value 0x243185be
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 12
{u32_push(0x550c7dc3)} // Push constant K[11] value 0x550c7dc3
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 13
{u32_push(0x72be5d74)} // Push constant K[12] value 0x72be5d74
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 14
{u32_push(0x80deb1fe)} // Push constant K[13] value 0x80deb1fe
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 15
{u32_push(0x9bdc06a7)} // Push constant K[14] value 0x9bdc06a7
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 16
{u32_push(0xc19bf174)} // Push constant K[15] value 0xc19bf174
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 17
{u32_push(0xe49b69c1)} // Push constant K[16] value 0xe49b69c1
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 18
{u32_push(0xefbe4786)} // Push constant K[17] value 0xefbe4786
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 19
{u32_push(0xfc19dc6)} // Push constant K[18] value 0xfc19dc6
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 20
{u32_push(0x240ca1cc)} // Push constant K[19] value 0x240ca1cc
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 21
{u32_push(0x2de92c6f)} // Push constant K[20] value 0x2de92c6f
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 22
{u32_push(0x4a7484aa)} // Push constant K[21] value 0x4a7484aa
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 23
{u32_push(0x5cb0a9dc)} // Push constant K[22] value 0x5cb0a9dc
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 24
{u32_push(0x76f988da)} // Push constant K[23] value 0x76f988da
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 25
{u32_push(0x983e5152)} // Push constant K[24] value 0x983e5152
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 26
{u32_push(0xa831c66d)} // Push constant K[25] value 0xa831c66d
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 27
{u32_push(0xb00327c8)} // Push constant K[26] value 0xb00327c8
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 28
{u32_push(0xbf597fc7)} // Push constant K[27] value 0xbf597fc7
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 29
{u32_push(0xc6e00bf3)} // Push constant K[28] value 0xc6e00bf3
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 30
{u32_push(0xd5a79147)} // Push constant K[29] value 0xd5a79147
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 31
{u32_push(0x6ca6351)} // Push constant K[30] value 0x6ca6351
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 32
{u32_push(0x14292967)} // Push constant K[31] value 0x14292967
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 33
{u32_push(0x27b70a85)} // Push constant K[32] value 0x27b70a85
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 34
{u32_push(0x2e1b2138)} // Push constant K[33] value 0x2e1b2138
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 35
{u32_push(0x4d2c6dfc)} // Push constant K[34] value 0x4d2c6dfc
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 36
{u32_push(0x53380d13)} // Push constant K[35] value 0x53380d13
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 37
{u32_push(0x650a7354)} // Push constant K[36] value 0x650a7354
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 38
{u32_push(0x766a0abb)} // Push constant K[37] value 0x766a0abb
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 39
{u32_push(0x81c2c92e)} // Push constant K[38] value 0x81c2c92e
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 40
{u32_push(0x92722c85)} // Push constant K[39] value 0x92722c85
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 41
{u32_push(0xa2bfe8a1)} // Push constant K[40] value 0xa2bfe8a1
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 42
{u32_push(0xa81a664b)} // Push constant K[41] value 0xa81a664b
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 43
{u32_push(0xc24b8b70)} // Push constant K[42] value 0xc24b8b70
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 44
{u32_push(0xc76c51a3)} // Push constant K[43] value 0xc76c51a3
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 45
{u32_push(0xd192e819)} // Push constant K[44] value 0xd192e819
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 46
{u32_push(0xd6990624)} // Push constant K[45] value 0xd6990624
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 47
{u32_push(0xf40e3585)} // Push constant K[46] value 0xf40e3585
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 48
{u32_push(0x106aa070)} // Push constant K[47] value 0x106aa070
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 49
{u32_push(0x19a4c116)} // Push constant K[48] value 0x19a4c116
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 50
{u32_push(0x1e376c08)} // Push constant K[49] value 0x1e376c08
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 51
{u32_push(0x2748774c)} // Push constant K[50] value 0x2748774c
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 52
{u32_push(0x34b0bcb5)} // Push constant K[51] value 0x34b0bcb5
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 53
{u32_push(0x391c0cb3)} // Push constant K[52] value 0x391c0cb3
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 54
{u32_push(0x4ed8aa4a)} // Push constant K[53] value 0x4ed8aa4a
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 55
{u32_push(0x5b9cca4f)} // Push constant K[54] value 0x5b9cca4f
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 56
{u32_push(0x682e6ff3)} // Push constant K[55] value 0x682e6ff3
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 57
{u32_push(0x748f82ee)} // Push constant K[56] value 0x748f82ee
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 58
{u32_push(0x78a5636f)} // Push constant K[57] value 0x78a5636f
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 59
{u32_push(0x84c87814)} // Push constant K[58] value 0x84c87814
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 60
{u32_push(0x8cc70208)} // Push constant K[59] value 0x8cc70208
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 61
{u32_push(0x90befffa)} // Push constant K[60] value 0x90befffa
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 62
{u32_push(0xa4506ceb)} // Push constant K[61] value 0xa4506ceb
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 63
{u32_push(0xbef9a3f7)} // Push constant K[62] value 0xbef9a3f7
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Round 64
{u32_push(0xc67178f2)} // Push constant K[63] value 0xc67178f2
{u32_add()} // Add K[t] and W[t]
{
        u32_push(0x510e527f)  // Push x
        u32_rrot(6)       // Rotate right by 6 bits
        u32_push(0x510e527f)  // Push x again
        u32_rrot(11)      // Rotate right by 11 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x510e527f)  // Push x again
        u32_rrot(25)      // Rotate right by 25 bits
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // XOR the top two values on the stack, result is sigma1
    }
{u32_add()} // Add result of sigma1(e) to (K[t] + W[t])
{
        u32_push(0x510e527f)
        u32_push(0x9b05688c)
        u32_and()
        u32_push(0x510e527f)
        u32_not()
        u32_push(0x1f83d9ab)
        u32_and()
        u32_xor()  // Ch result is on top of the stack
    }
{u32_add()} // Add result of Ch(e, f, g) to get T1
{u32_push(0x5be0cd19)} // Push current hash value h
{u32_add()} // Add T1 to h to get the new h
{
        u32_push(0x6a09e667)  // Push x
        u32_rrot(7)       // Rotate right by 7 bits
        u32_push(0x6a09e667)  // Push x again
        u32_rrot(18)      // Rotate right by 18 bits
        u32_xor()         // XOR the top two values on the stack
        u32_push(0x6a09e667)  // Push x again
        u32_shr(3)        // Shift right by 3 bits (if u32_shr is available)
        u32_xor()         // XOR the top two values on the stack
        u32_xor()         // Final XOR for sigma0 result
    }
{
        u32_push(0x6a09e667)
        u32_push(0xbb67ae85)
        u32_and()
        u32_push(0x6a09e667)
        u32_push(0x3c6ef372)
        u32_and()
        u32_push(0xbb67ae85)
        u32_push(0x3c6ef372)
        u32_and()
        u32_xor()
        u32_xor()  // Maj result is on top of the stack
    }
{u32_add()} // Add Maj(a, b, c) to Sigma0(a) to get T2
{u32_push(0x6a09e667)} // Push current value of a
{u32_add()} // Add T2 to a to get the new a
{u32_zip(0x5be0cd19, 0x1f83d9ab)} // Zip and prepare for next round
{u32_zip(0x1f83d9ab, 0x9b05688c)}
{u32_zip(0x9b05688c, 0x510e527f)}
{u32_zip(0x510e527f, 0xa54ff53a)}
{u32_zip(0xa54ff53a, 0x3c6ef372)}
{u32_zip(0x3c6ef372, 0xbb67ae85)}
{u32_zip(0xbb67ae85, 0x6a09e667)}
// Finalize hash values by combining with initial hash state
// Finalize updated hash values with initial values
{u32_add(0x6a09e667, 0x6a09e667)} // Add final round results to initial hash value H_INIT[0]
{u32_add(0xbb67ae85, 0x6a09e667)} // Add final round results to initial hash value H_INIT[1]
{u32_add(0x3c6ef372, 0x6a09e667)} // Add final round results to initial hash value H_INIT[2]
{u32_add(0xa54ff53a, 0x6a09e667)} // Add final round results to initial hash value H_INIT[3]
{u32_add(0x510e527f, 0x6a09e667)} // Add final round results to initial hash value H_INIT[4]
{u32_add(0x9b05688c, 0x6a09e667)} // Add final round results to initial hash value H_INIT[5]
{u32_add(0x1f83d9ab, 0x6a09e667)} // Add final round results to initial hash value H_INIT[6]
{u32_add(0x5be0cd19, 0x6a09e667)} // Add final round results to initial hash value H_INIT[7]

Received message: Crossbow toilet killing Game Of Thrones
